++            ax=self.xyz_ax,
++            canvas=self.xyz_canvas,
++            robot_chain=self.robot_chain,
++            ikpy_available=IKPY_AVAILABLE,)
++        
+         update_btn = QPushButton("Обновить визуализацию")
+         update_btn.clicked.connect(self.update_xyz_plot)
+         vis_layout.addWidget(update_btn)
+@@ -1369,6 +1380,9 @@ class ServiceTab(QWidget):
+         self.joints_canvas.setMinimumSize(400, 350)  # Фиксируем минимальный размер
+         vis_layout.addWidget(self.joints_canvas)
+         
++        self.joints_trajectory_plotter = JointsTrajectoryPlotter(
++            self.joints_ax, self.joints_canvas)
++        
+         update_btn = QPushButton("Обновить визуализацию")
+         update_btn.clicked.connect(self.update_joints_plot)
+         vis_layout.addWidget(update_btn)
+@@ -1539,6 +1553,10 @@ class ServiceTab(QWidget):
+         self.xyz_traj_canvas = FigureCanvas(self.xyz_traj_fig)
+         vis_layout.addWidget(self.xyz_traj_canvas)
+         
++        self.xyz_trajectory_plotter = XYZTrajectoryPlotter(
++            ax=self.xyz_traj_ax,
++            canvas=self.xyz_traj_canvas,)
++        
+         vis_frame.setLayout(vis_layout)
+         layout.addWidget(vis_frame)
+         
+@@ -1707,57 +1725,12 @@ class ServiceTab(QWidget):
+ 
+     @Slot()
+     def update_xyz_plot(self):
+-            """Обновление графика с кинематической цепочкой для осей XYZ"""
+-            self.xyz_ax.clear()
+-            
+-            x, y, z = self.controller.current_x, self.controller.current_y, self.controller.current_z
+-            
+-            # Отображаем кинематическую цепочку, если доступна
+-            if self.robot_chain and IKPY_AVAILABLE:
+-                try:
+-                    # Преобразуем координаты в метры для ikpy (из мм в метры)
+-                    target_position = [x/1000.0, y/1000.0, z/1000.0]
+-                    
+-                    # Вычисляем обратную кинематику
+-                    # Используем ориентацию по умолчанию (можно настроить под ваши нужды)
+-                    target_orientation = [0, 0, 0]  # [roll, pitch, yaw] в радианах
+-                    
+-                    # Вычисляем углы суставов через обратную кинематику
+-                    joint_angles = self.robot_chain.inverse_kinematics(
+-                        target_position=target_position,
+-                        target_orientation=target_orientation,
+-                        orientation_mode="all"
+-                    )
+-                    
+-                    # Отображаем кинематическую цепочку
+-                    self.robot_chain.plot(joint_angles, self.xyz_ax, target=target_position)
+-                    
+-                    # Добавляем целевую точку
+-                    self.xyz_ax.scatter([x/1000], [y/1000], [z/1000], 
+-                                    c='red', marker='o', s=100, label='Целевая позиция')
+-                    
+-                except Exception as e:
+-                    logger(f"Error inverse kinematic {e}", queue=q)
+-                    # Резервный вариант - просто показать точку
+-                    self.xyz_ax.scatter([x], [y], [z], c='r', marker='o', s=100, label='Позиция инструмента')
+-            else:
+-                # Резервный вариант без кинематики
+-                self.xyz_ax.scatter([x], [y], [z], c='r', marker='o', s=100, label='Позиция инструмента')
+-            
+-            # Настраиваем график
+-            self.xyz_ax.set_xlabel('X (м)')
+-            self.xyz_ax.set_ylabel('Y (м)')
+-            self.xyz_ax.set_zlabel('Z (м)')
+-            self.xyz_ax.set_title('Кинематическая цепочка робота')
+-            self.xyz_ax.legend()
+-            
+-            # Устанавливаем разумные пределы
+-            padding = 0.5  # 50 см в метрах
+-            self.xyz_ax.set_xlim([x/1000 - padding, x/1000 + padding])
+-            self.xyz_ax.set_ylim([y/1000 - padding, y/1000 + padding])
+-            self.xyz_ax.set_zlim([max(0, z/1000 - padding), z/1000 + padding])
+-            
+-            self.xyz_canvas.draw()
++        """Обновление графика XYZ"""
++        self.xyz_kinematics_plotter.plot(
++            x=self.controller.current_x,
\ No newline at end of file


FILE: scripts/commits/0f36aa38ffbb857a530120ba3813a8d99da88b83/chunk_1.txt
LANG: txt

new file mode 100644
index 0000000..2a558b3
--- /dev/null
+++ b/scripts/commits/0f36aa38ffbb857a530120ba3813a8d99da88b83/chunk_1.txt
@@ -0,0 +1,198 @@
++            y=self.controller.current_y,
++            z=self.controller.current_z,
++        )
+ 
+ 
+     # Методы управления суставами
+@@ -1833,7 +1806,9 @@ class ServiceTab(QWidget):
+         self.xyz_listbox.clear()
+         self.xyz_listbox.addItem(f"1: X: {x:.2f}, Y: {y:.2f}, Z: {z:.2f}")
+ 
+-        self.update_xyz_trajectory_plot()
++        self.xyz_trajectory_plotter.plot(
++            self.trajectory_service.get_points())
++
+ 
+     @Slot()
+     def add_xyz_point(self):
+@@ -1847,7 +1822,9 @@ class ServiceTab(QWidget):
+             self.xyz_listbox.addItem(
+                 f"{index}: X: {x:.2f}, Y: {y:.2f}, Z: {z:.2f}"
+             )
+-            self.update_xyz_trajectory_plot()
++            self.xyz_trajectory_plotter.plot(
++                self.trajectory_service.get_points())
++            
+         else:
+             logger("The point cannot be moved.", queue=q)
+ 
+@@ -1866,13 +1843,15 @@ class ServiceTab(QWidget):
+                     f"{i + 1}: X: {x:.2f}, Y: {y:.2f}, Z: {z:.2f}"
+                 )
+ 
+-            self.update_xyz_trajectory_plot()
++            self.xyz_trajectory_plotter.plot(
++                self.trajectory_service.get_points())
+ 
+     @Slot()
+     def clear_xyz_trajectory(self):
+         self.trajectory_service.clear()
+         self.xyz_listbox.clear()
+-        self.update_xyz_trajectory_plot()
++        self.xyz_trajectory_plotter.plot(
++            self.trajectory_service.get_points())
+ 
+ 
+     @Slot()
+@@ -1939,7 +1918,8 @@ class ServiceTab(QWidget):
+             self.trajectory_points_joints.add_point(joints)
+             index = len(self.trajectory_points_joints.get_points())