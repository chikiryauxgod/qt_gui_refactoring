++        assert received[0] == "hello"
++    finally:
++        thread.stop()
++
++
++def test_no_message_when_queue_empty(qapp):
++    q = queue.Queue()
++    source = QueueMessageSource(q)
++    thread = LogTextBoxErrosion(source, latency_ms=5)
++
++    received = []
++    thread.new_message.connect(received.append)
++
++    thread.start()
++    try:
++        time.sleep(0.05)
++        assert received == []
++    finally:
++        thread.stop()
++
++
++def test_multiple_messages_order(qapp):
++    q = queue.Queue()
++    source = QueueMessageSource(q)
++    thread = LogTextBoxErrosion(source, latency_ms=1)
++
++    received = []
++    thread.new_message.connect(received.append)
++
++    thread.start()
++    try:
++        q.put("m1")
++        q.put("m2")
++        q.put("m3")
++
++        assert wait_until(lambda: len(received) >= 3, timeout_ms=1500), "Не все сообщения дошли"
++        assert received[:3] == ["m1", "m2", "m3"]
++    finally:
++        thread.stop()


FILE: scripts/commits/5bc47e2f492c6c805c3fc0a826fc9f39fbc6b97d.raw
LANG: raw

new file mode 100644
index 0000000..19745e5
--- /dev/null
+++ b/scripts/commits/5bc47e2f492c6c805c3fc0a826fc9f39fbc6b97d.raw
@@ -0,0 +1,208 @@
+commit 5bc47e2f492c6c805c3fc0a826fc9f39fbc6b97d
+Author:     Matvey <matveykroychelove4ek@gmail.com>
+AuthorDate: Wed Jan 21 14:42:46 2026 +0500
+Commit:     Matvey <matveykroychelove4ek@gmail.com>
+CommitDate: Wed Jan 21 14:42:46 2026 +0500
+
+    feat: refactored class LogTextBoxErrosion, add test
+
+


FILE: src/LogText/LogTextBoxErrosion.py
LANG: py

+new file mode 100644
+index 0000000..050bf27
+--- /dev/null
++++ b/src/LogText/LogTextBoxErrosion.py
+@@ -0,0 +1,45 @@
++from __future__ import annotations
++
++import queue
++from abc import ABC, abstractmethod
++from typing import Optional
++
++from PySide6.QtCore import QThread, Signal
++
++
++class MessageSource(ABC):
++    @abstractmethod
++    def try_get(self) -> Optional[str]:
++        """Вернуть сообщение или None, если пока нет."""
++        ...
++
++class QueueMessageSource(MessageSource):
++    def __init__(self, message_queue: queue.Queue):
++        self._q = message_queue
++
++    def try_get(self) -> Optional[str]:
++        try:
++            return self._q.get_nowait()
++        except queue.Empty:
++            return None
++
++class LogTextBoxErrosion(QThread):
++    new_message = Signal(str)
++
++    def __init__(self, source: MessageSource, latency_ms: int = 100):
++        super().__init__()
++        self._source = source
++        self._latency_ms = latency_ms
++        self._running = True
++
++    def run(self):
++        while self._running:
++            msg = self._source.try_get()
++            if msg is None:
++                self.msleep(self._latency_ms)
++                continue
++            self.new_message.emit(msg)
++
++    def stop(self):
++        self._running = False
++        self.wait()
+\ No newline at end of file
+


FILE: src/LogText/__init__.py
LANG: py

+new file mode 100644
+index 0000000..e69de29
+


FILE: src/qt_interface.py
LANG: py

+index f1864a3..8fc3ffe 100644
+--- a/src/qt_interface.py
++++ b/src/qt_interface.py
+@@ -29,6 +29,7 @@ from .log import Log
+ from src.arrow3D import Arrow3D, Arrow3DData
+ from src.widgets.axis_control_widget import AxisControlWidget
+ from src.erosion_worker.errosion_worker import ErosionWorker, ErosionController, GCodeProcessor
++from src.LogText.LogTextBoxErrosion import QueueMessageSource, LogTextBoxErrosion
+ 
+ 
+ #+ Передать в electroerosion очередь, она заполняется в port и robot, её нужно просто туда передать
+@@ -289,7 +290,8 @@ class ErosionProcessTab(QWidget):
+ 
+     def start_queue_reader(self):
+         """Запуск потока чтения из очереди"""
+-        self.queue_reader = LogTextBoxErrosion(q)
++        source = QueueMessageSource(q)
++        self.queue_reader = LogTextBoxErrosion(source, latency_ms =100)
+         self.queue_reader.new_message.connect(self.append_to_status_text)
+         self.queue_reader.start()
+         
+@@ -2501,10 +2503,10 @@ class MainWindow(QMainWindow):
+             background-color: {color};
+         """)
+ 
+-class LogTextBoxErrosion(QThread):
++""" class LogTextBoxErrosion(QThread):
+ 
+     new_message = Signal(str)
+-    def __init__(self, queue):
++    def __init__(self, queue, latency=100):
+         super().__init__()
+         self.queue = queue
+         self.running = True
+@@ -2517,11 +2519,11 @@ class LogTextBoxErrosion(QThread):
+                 self.new_message.emit(message)
+             except queue.Empty:
+                 # Если очередь пуста, ждем немного и продолжаем
+-                QThread.msleep(100)
++                self.msleep(self.latency)
+                 continue
+ 
+     def stop(self):
+-        self.running = False
++        self.running = False """
+ 
+ 
+ # Запуск приложения
+


FILE: tests/LogTextBoxErrosion/test_log_text_errosion.py
LANG: py

+new file mode 100644
+index 0000000..5163b6d
+--- /dev/null
++++ b/tests/LogTextBoxErrosion/test_log_text_errosion.py
+@@ -0,0 +1,90 @@
++import queue
++import time
++
++import pytest
++from PySide6.QtCore import QCoreApplication, QEventLoop, QTimer
++
++from src.LogText.LogTextBoxErrosion import QueueMessageSource, LogTextBoxErrosion
++
++
++@pytest.fixture(scope="session", autouse=True)
++def qapp():
++    app = QCoreApplication.instance()
++    if app is None:
++        app = QCoreApplication([])
++    return app
++
++
++def wait_until(predicate, timeout_ms: int = 1000, step_ms: int = 10) -> bool:
++    loop = QEventLoop()
++    ok = {"value": False}
++
++    def tick():
++        if predicate():
++            ok["value"] = True
++            loop.quit()
++
++    timer = QTimer()
++    timer.setInterval(step_ms)
++    timer.timeout.connect(tick)
++    timer.start()
++
++    QTimer.singleShot(timeout_ms, loop.quit)
++    loop.exec()
++
++    timer.stop()
++    return ok["value"]
++
++
++def test_emits_message_from_queue(qapp):
++    q = queue.Queue()
++    source = QueueMessageSource(q)
++    thread = LogTextBoxErrosion(source, latency_ms=5)
++
++    received = []
++    thread.new_message.connect(received.append)
++
++    thread.start()
++    try:
++        q.put("hello")