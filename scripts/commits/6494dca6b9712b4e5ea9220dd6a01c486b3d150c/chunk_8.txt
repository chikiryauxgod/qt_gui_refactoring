+             self.joints_listbox.addItem(f"{index}: J0: {joints[0]:.2f}, J1: {joints[1]:.2f}, J2: {joints[2]:.2f}")
+-            self.update_joints_trajectory_plot()
++            self.joints_trajectory_plotter.plot(
++                self.trajectory_points_joints.get_points())
+         else:
+             # QMessageBox.critical(self, "Ошибка", "Позиция недоступна для перемещения")
+             logger("The position cannot be moved.", queue=q)
+@@ -1950,13 +1930,14 @@ class ServiceTab(QWidget):
+         if current_row >= 0:
+             self.joints_listbox.takeItem(current_row)
+             self.joint_trajectory_service.remove_point(current_row)
+-            self.update_joints_trajectory_plot()
+-
++            self.joints_trajectory_plotter.plot(
++                self.trajectory_points_joints.get_points())
+     @Slot()
+     def clear_joints_trajectory(self):
+         self.joints_listbox.clear()
+         self.trajectory_points_joints.clear()
+-        self.update_joints_trajectory_plot()
++        self.joints_trajectory_plotter.plot(
++                self.trajectory_points_joints.get_points())
+ 
+     @Slot()
+     def return_to_zero_joints(self):
+
+
+FILE: src/visualization/joints_trajectory_plotter.py
+LANG: py
+
+new file mode 100644
+index 0000000..f7f9c53
+--- /dev/null
++++ b/src/visualization/joints_trajectory_plotter.py
+@@ -0,0 +1,18 @@
++class JointsTrajectoryPlotter:
++    def __init__(self, ax, canvas):
++        self._ax = ax
++        self._canvas = canvas
++
++    def plot(self, trajectories: list[list[float]]) -> None:
++        self._ax.clear()
++
++        if not trajectories:
++            self._canvas.draw()
++            return
++
++        for joint_index, joint_values in enumerate(zip(*trajectories)):
++            self._ax.plot(joint_values, label=f"J{joint_index}")
++
++        self._ax.legend()
++        self._ax.set_title("Траектория суставов")
++        self._canvas.draw()
+
+
+FILE: src/visualization/xyz_kinematics_plotter.py
+LANG: py
+
+new file mode 100644
+index 0000000..cfdc2dd
+--- /dev/null
++++ b/src/visualization/xyz_kinematics_plotter.py
+@@ -0,0 +1,56 @@
++class XYZKinematicsPlotter:
++    def __init__(
++        self,
++        ax,
++        canvas,
++        robot_chain=None,
++        ikpy_available: bool = False,
++    ):
++        self._ax = ax
++        self._canvas = canvas
++        self._robot_chain = robot_chain
++        self._ikpy_available = ikpy_available
++
++    def plot(self, x: float, y: float, z: float) -> None:
++        self._ax.clear()
++
++        if self._robot_chain and self._ikpy_available:
++            self._plot_with_kinematics(x, y, z)
++        else:
++            self._plot_point(x, y, z)
++
++        self._configure_axes(x, y, z)
++        self._canvas.draw()
++
++    def _plot_with_kinematics(self, x, y, z):
++        try:
++            target = [x / 1000, y / 1000, z / 1000]
++            joint_angles = self._robot_chain.inverse_kinematics(
++                target_position=target,
++                target_orientation=[0, 0, 0],
++                orientation_mode="all",
++            )
++            self._robot_chain.plot(joint_angles, self._ax, target=target)
++            self._ax.scatter(*target, c="red", s=100)
++        except Exception:
++            self._plot_point(x, y, z)
++
++    def _plot_point(self, x, y, z):
++        self._ax.scatter(
++            [x / 1000],
++            [y / 1000],
++            [z / 1000],
++            c="red",
++            s=100,
++        )
++
++    def _configure_axes(self, x, y, z):
++        padding = 0.5
++        self._ax.set_title("Кинематическая цепочка робота")
++        self._ax.set_xlabel("X (м)")
++        self._ax.set_ylabel("Y (м)")
++        self._ax.set_zlabel("Z (м)")
++
++        self._ax.set_xlim([x / 1000 - padding, x / 1000 + padding])
++        self._ax.set_ylim([y / 1000 - padding, y / 1000 + padding])
++        self._ax.set_zlim([max(0, z / 1000 - padding), z / 1000 + padding])
+
+
+FILE: src/visualization/xyz_trajectory_plotter.py
+LANG: py
+
+new file mode 100644
+index 0000000..c158798
+--- /dev/null
++++ b/src/visualization/xyz_trajectory_plotter.py
+@@ -0,0 +1,21 @@
++import numpy as np
++
++
++class XYZTrajectoryPlotter:
++    def __init__(self, ax, canvas):
++        self._ax = ax
++        self._canvas = canvas
++
++    def plot(self, points: list[tuple[float, float, float]]) -> None:
++        self._ax.clear()
++
++        if not points:
++            self._canvas.draw()
++            return
++
++        pts = np.array(points)
++        self._ax.plot(pts[:, 0], pts[:, 1], pts[:, 2])
++        self._ax.scatter(pts[:, 0], pts[:, 1], pts[:, 2])
++
++        self._ax.set_title("Траектория XYZ")
\ No newline at end of file


FILE: scripts/commits/0f36aa38ffbb857a530120ba3813a8d99da88b83/chunk_2.txt
LANG: txt

new file mode 100644
index 0000000..9795dd3
--- /dev/null
+++ b/scripts/commits/0f36aa38ffbb857a530120ba3813a8d99da88b83/chunk_2.txt
@@ -0,0 +1,146 @@
++        self._canvas.draw()
+
+
+FILE: tests/test_joints_trajectory_plotter.py
+LANG: py
+
+new file mode 100644
+index 0000000..5f4a550
+--- /dev/null
++++ b/tests/test_joints_trajectory_plotter.py
+@@ -0,0 +1,18 @@
++from unittest.mock import Mock
++from src.visualization.joints_trajectory_plotter import JointsTrajectoryPlotter
++
++
++def test_joints_trajectory_plot_calls_draw():
++    ax = Mock()
++    canvas = Mock()
++
++    plotter = JointsTrajectoryPlotter(ax, canvas)
++
++    trajectories = [
++        [0, 0, 0, 0, 0, 0],
++        [10, 20, 30, 40, 50, 60],
++    ]
++
++    plotter.plot(trajectories)
++
++    canvas.draw.assert_called_once()
+
+
+FILE: tests/test_xyz_kinematics_plotter.py
+LANG: py
+
+new file mode 100644
+index 0000000..67402f5
+--- /dev/null
++++ b/tests/test_xyz_kinematics_plotter.py
+@@ -0,0 +1,76 @@
++from unittest.mock import Mock
++from src.visualization.xyz_kinematics_plotter import XYZKinematicsPlotter
++
++def test_plot_calls_canvas_draw():
++    ax = Mock()
++    canvas = Mock()
++    robot_chain = Mock()
++
++    robot_chain.inverse_kinematics.return_value = [0, 0, 0]
++    robot_chain.plot.return_value = None
++
++    plotter = XYZKinematicsPlotter(