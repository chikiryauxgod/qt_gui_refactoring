++from .widgets.axis_control_widget import AxisControlWidget
++from .widgets.axis_control_config import AxisControlConfig
+ 
+ 
+ #+ Передать в electroerosion очередь, она заполняется в port и robot, её нужно просто туда передать
+@@ -70,11 +72,14 @@ class VideoStreamThread(QThread):
+         while self.running:
+             if self.cap.isOpened():
+                 ret, frame = self.cap.read()
++                if not ret:
++                    self.running = False
++                    break
+                 if ret:
+                     rgb_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
+                     h, w, ch = rgb_image.shape
+                     bytes_per_line = ch * w
+-                    qt_image = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888)
++                    qt_image = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888).copy()
+                     self.new_frame.emit(qt_image)
+             self.msleep(self.latency)
+             
+@@ -2579,4 +2584,4 @@ if __name__ == "__main__":
+     window = MainWindow()
+     window.showMaximized()
+     
+-    sys.exit(app.exec())
++    sys.exit(app.exec())
+\ No newline at end of file
+
+
+FILE: tests/VideoStreamThread/test_video_stream_thread.py
+LANG: py
+
+index cd4752b..de25024 100644
+--- a/tests/VideoStreamThread/test_video_stream_thread.py
++++ b/tests/VideoStreamThread/test_video_stream_thread.py
+@@ -1,5 +1,3 @@
+-
+-
+ import numpy as np
+ import pytest
+ import sys, types
+@@ -35,7 +33,7 @@ class FakeCapture:
+             frame = np.zeros((10, 10, 3), dtype=np.uint8)
+             return True, frame
+ 
+-        # после первого кадра считаем, что камера закончилась/закрылась
++   
+         self._released = True
+         return False, None
+ 
+@@ -50,7 +48,7 @@ def patch_cv2(monkeypatch):
+         return FakeCapture(idx)
+ 
+     def fake_cvtcolor(frame, code):
+-        return frame  # нам не важно, что именно делает конвертация
++        return frame  
+ 
+     monkeypatch.setattr(qi.cv2, "VideoCapture", fake_videocapture)
+     monkeypatch.setattr(qi.cv2, "cvtColor", fake_cvtcolor)
+@@ -63,9 +61,9 @@ def test_run_finishes_when_capture_ends(patch_cv2):
+     """
+     t = VideoStreamThread(camera_idx=0, width=640, height=480, latency=1)
+ 
+-    # на всякий случай: ограничим время выполнения теста логикой в FakeCapture
++    
+     t.running = True
+     t.run()
+ 
+-    # После выполнения run() камера должна быть "закрыта"
++    
+     assert t.cap.isOpened() is False
+\ No newline at end of file
\ No newline at end of file


FILE: scripts/commits/cf9b9778f8f8fb8c55060a0184eeffcda0c0ff11.norm
LANG: norm

new file mode 100644
index 0000000..3395ed9
--- /dev/null
+++ b/scripts/commits/cf9b9778f8f8fb8c55060a0184eeffcda0c0ff11.norm
@@ -0,0 +1,276 @@
+commit cf9b9778f8f8fb8c55060a0184eeffcda0c0ff11
+Author:     Matvey <matveykroychelove4ek@gmail.com>
+AuthorDate: Wed Jan 21 15:54:50 2026 +0500
+Commit:     Matvey <matveykroychelove4ek@gmail.com>
+CommitDate: Wed Jan 21 15:54:50 2026 +0500
+
+    feat: refactor VideoStreamThread class, upd test
+
+
+FILES:
+
+FILE: src/VideoStream/VideoStreamThread.py
+LANG: py
+
+new file mode 100644
+index 0000000..c9e27aa
+--- /dev/null
++++ b/src/VideoStream/VideoStreamThread.py
+@@ -0,0 +1,108 @@
++from __future__ import annotations
++
++from abc import ABC, abstractmethod
++from typing import Optional, Tuple
++
++import cv2
++import numpy as np
++
++from PySide6.QtCore import QThread, Signal
++from PySide6.QtGui import QImage
++
++class FrameSource(ABC):
++    @abstractmethod
++    def open(self) -> bool: ...
++    @abstractmethod
++    def is_opened(self) -> bool: ...
++    @abstractmethod
++    def read(self) -> Tuple[bool, Optional[np.ndarray]]: ...
++    @abstractmethod
++    def close(self) -> None: ...
++
++
++class FrameConverter(ABC):
++    @abstractmethod
++    def to_qimage(self, frame_bgr: np.ndarray) -> QImage: ...
++
++
++class OpenCVCameraSource(FrameSource):
++    def __init__(self, camera_idx: int = 0, width: int = 640, height: int = 480):
++        self._camera_idx = camera_idx
++        self._width = width
++        self._height = height
++        self._cap: Optional[cv2.VideoCapture] = None
++
++    def open(self) -> bool:
++        self._cap = cv2.VideoCapture(self._camera_idx)
++        if not self._cap or not self._cap.isOpened():
++            self._cap = None
++            return False
++
++        self._cap.set(cv2.CAP_PROP_FRAME_WIDTH, self._width)
++        self._cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self._height)
++        return True
++
++    def is_opened(self) -> bool:
++        return bool(self._cap and self._cap.isOpened())
++
++    def read(self) -> Tuple[bool, Optional[np.ndarray]]:
++        if not self.is_opened():
++            return False, None
++        ret, frame = self._cap.read()
++        return ret, frame if ret else None
++
++    def close(self) -> None:
++        if self._cap and self._cap.isOpened():
++            self._cap.release()
++        self._cap = None
++
++
++class BGRToRGB888QImageConverter(FrameConverter):
++    def to_qimage(self, frame_bgr: np.ndarray) -> QImage:
++        rgb = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2RGB)
++        h, w, ch = rgb.shape
++        bytes_per_line = ch * w
++        return QImage(rgb.data, w, h, bytes_per_line, QImage.Format_RGB888).copy()
++
++class VideoStreamThread(QThread):
++    new_frame = Signal(QImage)
++    error = Signal(str)
++
++    def __init__(
++        self,
++        source: Optional[FrameSource] = None,
++        converter: Optional[FrameConverter] = None,
++        latency: int = 30,
++    ):
++        super().__init__()
++        self._source = source or OpenCVCameraSource(camera_idx=0, width=640, height=480)
++        self._converter = converter or BGRToRGB888QImageConverter()
++        self._latency = latency
++        self._running = True
++
++    def run(self):
++        if not self._source.open():
++            self.error.emit("Не удалось открыть видеопоток (источник не открылся).")
++            return
++
++        try:
++            while self._running:
++                if not self._source.is_opened():
++                    self.error.emit("Видеопоток недоступен (источник закрылся).")