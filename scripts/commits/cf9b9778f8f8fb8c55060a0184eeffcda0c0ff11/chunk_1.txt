         return True
 
+    def is_opened(self) -> bool:
+        return self._opened and not self.closed
+
     def read(self):
         self._read_count += 1
         if self._read_count == 1:
             frame = np.zeros((10, 10, 3), dtype=np.uint8)
             return True, frame
-
-   
-        self._released = True
+        # заканчиваем поток
+        self.closed = True
         return False, None
 
-    def release(self):
-        self._released = True
-
+    def close(self) -> None:
+        self.closed = True
 
-@pytest.fixture
-def patch_cv2(monkeypatch):
-    """Патчим cv2 внутри src.qt_interface, чтобы не трогать реальную камеру."""
-    def fake_videocapture(idx):
-        return FakeCapture(idx)
 
-    def fake_cvtcolor(frame, code):
-        return frame  
+class FakeConverter(FrameConverter):
+    def to_qimage(self, frame_bgr: np.ndarray) -> QImage:
+        h, w, ch = frame_bgr.shape
+        return QImage(w, h, QImage.Format_RGB888)
 
-    monkeypatch.setattr(qi.cv2, "VideoCapture", fake_videocapture)
-    monkeypatch.setattr(qi.cv2, "cvtColor", fake_cvtcolor)
 
+def test_run_finishes_when_source_ends():
+    source = FakeSource()
+    converter = FakeConverter()
 
-def test_run_finishes_when_capture_ends(patch_cv2):
-    """
-    Тест НЕ проверяет сигнал new_frame.
-    Он проверяет главное: run() не уходит в вечный цикл, если камера "закончилась".
-    """
-    t = VideoStreamThread(camera_idx=0, width=640, height=480, latency=1)
+    t = VideoStreamThread(source=source, converter=converter, latency=1)
 
-    
-    t.running = True
+    # Важно: мы вызываем run() напрямую (как ты делал), без start()
     t.run()
 
-    
-    assert t.cap.isOpened() is False'''
\ No newline at end of file
+    assert source.closed is True
\ No newline at end of file