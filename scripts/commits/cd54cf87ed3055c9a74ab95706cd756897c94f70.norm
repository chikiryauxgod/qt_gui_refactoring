commit cd54cf87ed3055c9a74ab95706cd756897c94f70
Author:     Matvey <matveykroychelove4ek@gmail.com>
AuthorDate: Tue Jan 20 15:32:36 2026 +0500
Commit:     Matvey <matveykroychelove4ek@gmail.com>
CommitDate: Tue Jan 20 15:32:36 2026 +0500

    feat: bug fix with tests


FILES:

FILE: src/qt_interface.py
LANG: py

index ed3d514..b798b1e 100644
--- a/src/qt_interface.py
+++ b/src/qt_interface.py
@@ -8,10 +8,10 @@ import time
 import threading
 import queue
 import platform
-from src.electoerosion import Electroerosion
+from .electoerosion import Electroerosion
 
-from src.robot import Robot
-from src.pico import Pico
+from .robot import Robot
+from .pico import Pico
 from PySide6.QtWidgets import (QApplication, QMainWindow, QTabWidget, QWidget, QVBoxLayout, 
                               QHBoxLayout, QLabel, QPushButton, QDoubleSpinBox, QSpinBox,
                               QProgressBar, QTextEdit, QGroupBox, QFileDialog, QMessageBox,
@@ -25,8 +25,10 @@ from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
 from matplotlib.figure import Figure
 from matplotlib.patches import FancyArrowPatch
 from mpl_toolkits.mplot3d import proj3d
-from src.log import Log
+from .log import Log
 from src.arrow3D import Arrow3D, Arrow3DData
+from .widgets.axis_control_widget import AxisControlWidget
+from .widgets.axis_control_config import AxisControlConfig
 
 
 #+ Передать в electroerosion очередь, она заполняется в port и robot, её нужно просто туда передать
@@ -70,11 +72,14 @@ class VideoStreamThread(QThread):
         while self.running:
             if self.cap.isOpened():
                 ret, frame = self.cap.read()
+                if not ret:
+                    self.running = False
+                    break
                 if ret:
                     rgb_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                     h, w, ch = rgb_image.shape
                     bytes_per_line = ch * w
-                    qt_image = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888)
+                    qt_image = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888).copy()
                     self.new_frame.emit(qt_image)
             self.msleep(self.latency)
             
@@ -2579,4 +2584,4 @@ if __name__ == "__main__":
     window = MainWindow()
     window.showMaximized()
     
-    sys.exit(app.exec())
+    sys.exit(app.exec())
\ No newline at end of file


FILE: tests/VideoStreamThread/test_video_stream_thread.py
LANG: py

index cd4752b..de25024 100644
--- a/tests/VideoStreamThread/test_video_stream_thread.py
+++ b/tests/VideoStreamThread/test_video_stream_thread.py
@@ -1,5 +1,3 @@
-
-
 import numpy as np
 import pytest
 import sys, types
@@ -35,7 +33,7 @@ class FakeCapture:
             frame = np.zeros((10, 10, 3), dtype=np.uint8)
             return True, frame
 
-        # после первого кадра считаем, что камера закончилась/закрылась
+   
         self._released = True
         return False, None
 
@@ -50,7 +48,7 @@ def patch_cv2(monkeypatch):
         return FakeCapture(idx)
 
     def fake_cvtcolor(frame, code):
-        return frame  # нам не важно, что именно делает конвертация
+        return frame  
 
     monkeypatch.setattr(qi.cv2, "VideoCapture", fake_videocapture)
     monkeypatch.setattr(qi.cv2, "cvtColor", fake_cvtcolor)
@@ -63,9 +61,9 @@ def test_run_finishes_when_capture_ends(patch_cv2):
     """
     t = VideoStreamThread(camera_idx=0, width=640, height=480, latency=1)
 
-    # на всякий случай: ограничим время выполнения теста логикой в FakeCapture
+    
     t.running = True
     t.run()
 
-    # После выполнения run() камера должна быть "закрыта"
+    
     assert t.cap.isOpened() is False
\ No newline at end of file
